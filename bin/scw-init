#!/opt/local/bin/ruby1.9

require "bundler/setup"
Bundler.require(:default)

require "scm-workflow.rb"

require 'utils/repo/repo.rb'
require 'utils/repo/git/git.rb'
require 'scm-workflow/configuration.rb'
require 'scm-workflow/init-repo.rb'

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
def usage() 
  puts "Commands for initialization of a local repo."
  exit 0
end

#-----------------------------------------------------------------------------
# ................ A R G U M E N T S .. P R O C E S S I N G .................
#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# This hash will hold all of the options parsed from the command-line by
# OptionParser.
#-----------------------------------------------------------------------------
options = {}
loglevels = [:debug, :info, :warn, :error, :fatal]
 
optparse = OptionParser.new do|opts|
  # Set a banner, displayed at the top of the help screen.
  opts.banner = "Usage: optparse1.rb [options] file1 file2 ..."
   
  # Define the options, and what they do
  options[:quick] = false
  opts.on( '-q', '--quick', 'Perform the task quickly' ) do
  options[:quick] = true
  end
   
  options[:logfile] = nil
  opts.on( '-l', '--logfile FILE', 'Write log to FILE' ) do |file|
  options[:logfile] = file
  end
  
  options[:usage] = nil
  opts.on( '-u', '--usage', 'Print one liner about this script' ) do
     options[:usage] = true
  end

  options[:list] = []
  opts.on( '-l', '--list a,b,c', Array, "List of parameters" ) do |l|
    options[:list] = l
  end
  
  options[:loglevel] = nil
  opts.on( '-v', '--loglevel OPT', loglevels, "Log level" ) do |s|
    options[:loglevel] = s
  end 

  # This displays the help screen, all programs are assumed to have this 
  # option.
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end
 
#-----------------------------------------------------------------------------
# Parse the command-line. Remember there are two forms of the parse method. 
# The 'parse' method simply parses ARGV, while the 'parse!' method parses 
# ARGV and removes any options found there, as well as any parameters for the
# the options. What's left is the list of files to resize.
#-----------------------------------------------------------------------------
begin
  optparse.parse!
rescue => ex
  puts ex.to_s
  exit 1
end
usage if options[:usage]

puts "Being quick" if options[:quick]
puts "Logging to file #{options[:logfile]}" if options[:logfile]

loglevel = options[:loglevel]
logsettings = Scm::Workflow::Utils::LogSettings.instance
logsettings.level = loglevels.index(loglevel) if options[:loglevel]
logsettings.output = options[:logfile] if options[:logfile]

#-----------------------------------------------------------------------------
# ..................... E X E C U T I O N .. G U T S ........................
#-----------------------------------------------------------------------------
myRepo = Scm::Workflow::Utils::Repo::Git::GitRepo.new(Dir.pwd)
initWorkflow = Scm::Workflow::InitializeRepo.new(myRepo)

#-----------------------------------------------------------------------------
#-----------------------------------------------------------------------------
begin
  initWorkflow.execute { |configuration| 
    Scm::Workflow::Utils::Logging.instance.logger.warn("bll")
    configuration.instance_variables.each do |v|
      globalEntry = configuration.instance_variable_get(v)
      
      puts
      puts " > " + globalEntry.to_s
      globalEntry.instance_variables.each do |sv|
        entry = globalEntry.instance_variable_get(sv)
        info = entry.info;
        hideInput = entry.hideinput;
        question = "\tEnter the " + info + ": "
        #question = question.ljust(50)
        value = ask(question) { |q| q.echo = "*" } if hideInput
        value = ask(question) { |q| q.default = entry.value } if !hideInput
        entry.value = value
      end
    end
  }
  
rescue Interrupt => e
  puts "\ninterupted"
end

exit initWorkflow.wasSuccessfull? ? 0 : 1


